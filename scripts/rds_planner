#!/usr/bin/env python
import numpy as np
import rospy
import threading
from sensor_msgs.msg import LaserScan
from nav_msgs.msg import Odometry
from geometry_msgs.msg import Twist
from timeit import default_timer as timer
from visualization_msgs.msg import Marker
from geometry_msgs.msg import Point
from std_msgs.msg import String
from std_srvs.srv import Trigger, TriggerResponse
from rds_network_ros.srv import VelocityCommandCorrectionRDS, VelocityCommandCorrectionRDSRequest
from pose2d import Pose2D, apply_tf, apply_tf_to_vel, apply_tf_to_pose, inverse_pose2d

def remove_python2_entries_from_sys_path():
    """ sourcing ros means adding its python2 paths to sys.path. This creates incompatibilities when
    importing tf, so we remove them """
    import sys
    if sys.version[0] == str(3):
        new_path = []
        for p in sys.path:
            if "python2" in p:
                print("REMOVING python2 entry from sys.path: {}".format(p))
                continue
            new_path.append(p)
        sys.path = new_path


remove_python2_entries_from_sys_path()
import tf  # noqa

# local packages

PLAN_EVEN_IF_STOPPED = False
STEP_THROUGH_VEL = 0.07

class RDSPlanner(object):
    def __init__(self, args):
        self.args = args
        rospy.init_node('rdsplanner', anonymous=True)
        # consts
        self.kFixedFrameTopic = "/pepper_robot/odom"
        self.kCmdVelTopic = "/cmd_vel"
        self.kGesturesTopic = "/gestures"
        self.kGlobalWaypointTopic = "/global_planner/current_waypoint"
        self.kFixedFrame = "odom"  # ideally something truly fixed, like /map
        self.kRobotFrame = "base_footprint"
        self.kMaxObstacleVel_ms = 10.  # [m/s]
        self.kRobotComfortRadius_m = rospy.get_param("/robot_comfort_radius", 0.7)
        self.kRobotRadius_m = rospy.get_param("/robot_radius", 0.3)
        self.kGesturesCooldownTime = 6.  # seconds
        self.kMaxVelocity = 1.0
        self.kMaxAcc = 1.0
        self.kIdealVelocity = 0.4
        self.kDT = 0.1
        # vars
        self.msg_prev = None
        self.odom = None
        self.tf_rob_in_fix = None
        self.tf_goal_in_fix = None
        self.lock = threading.Lock()  # for avoiding race conditions
        self.STOP = True  # disables autonomous control
        self.last_tf_publish_time = None  # needed because of new TF_REPEATED_DATA warnings
        if args.no_stop:
            self.STOP = False
        self.GESTURES = False
        if args.gestures:
            self.GESTURES = True
        self.is_tracking_global_path = False
        self.step_through_flag = False
        # ROS
        rospy.Subscriber(self.kGlobalWaypointTopic, Marker, self.global_waypoint_callback, queue_size=1)
        rospy.Subscriber(self.kFixedFrameTopic, Odometry, self.odom_callback, queue_size=1)
        try:
            from frame_msgs.msg import TrackedPersons
            rospy.Subscriber("/rwth_tracker/tracked_persons", TrackedPersons,
                             self.trackedpersons_callback, queue_size=1)
        except ImportError:
            pass
        self.pubs = [rospy.Publisher("debug{}".format(i), LaserScan, queue_size=1) for i in range(3)]
        self.cmd_vel_pub = rospy.Publisher(self.kCmdVelTopic, Twist, queue_size=1)
        self.gestures_pub = rospy.Publisher(self.kGesturesTopic, String, queue_size=1)
        self.speech_pub = rospy.Publisher("/speech", String, queue_size=1)
        # tf
        self.tf_listener = tf.TransformListener()
        self.tf_br = tf.TransformBroadcaster()
        # Timers
        rospy.Timer(rospy.Duration(0.01), self.tf_callback)
        rospy.Timer(rospy.Duration(self.kDT), self.controller_routine)
        # Services
        rospy.Service('stop_autonomous_motion', Trigger,
                      self.stop_autonomous_motion_service_call)
        rospy.Service('resume_autonomous_motion', Trigger,
                      self.resume_autonomous_motion_service_call)
        rospy.Service('enable_gestures', Trigger,
                      self.enable_gestures_service_call)
        rospy.Service('disable_gestures', Trigger,
                      self.disable_gestures_service_call)
        try:
            rospy.spin()
        except KeyboardInterrupt:
            # publish cmd_vel
            cmd_vel_msg = Twist()
            self.cmd_vel_pub.publish(cmd_vel_msg)
            rospy.signal_shutdown('KeyboardInterrupt')

    def rds_correction(self, gx, gy):
        wpt_xy_in_rob = np.array([gx, gy])
        nominal_cmd_vel = np.array([0,0])
        if np.linalg.norm(wpt_xy_in_rob) != 0.:
            nominal_cmd_vel = wpt_xy_in_rob / np.linalg.norm(wpt_xy_in_rob) * self.kIdealVelocity

        # x is forward, y is left in cmd_vel. In rds, x is right, y is forward
        forward = nominal_cmd_vel[0]
        left = nominal_cmd_vel[1]

        virtual_center_y = 0.1
        request = VelocityCommandCorrectionRDSRequest()
        request.nominal_command.linear = forward
        request.nominal_command.angular = left / virtual_center_y
        request.capsule_center_front_y = virtual_center_y+0.01
        request.capsule_center_rear_y = virtual_center_y-0.01
        request.capsule_radius = self.kRobotRadius_m
        request.reference_point_y = virtual_center_y
        request.rds_tau = 1.0
        request.rds_delta = 0.05
        request.vel_lim_linear_min = -self.kMaxVelocity
        request.vel_lim_linear_max = self.kMaxVelocity
        request.vel_lim_angular_abs_max = self.kMaxVelocity / virtual_center_y
        request.vel_linear_at_angular_abs_max = 0.
        request.acc_limit_linear_abs_max = self.kMaxAcc
        request.acc_limit_angular_abs_max = self.kMaxAcc / virtual_center_y
        request.dt = self.kDT
        request.lrf_point_obstacles = True
        request.ORCA_implementation = False

        rospy.wait_for_service('rds_velocity_command_correction')
        try:
            rds_velocity_command_correction = rospy.ServiceProxy('rds_velocity_command_correction',
                                                                 VelocityCommandCorrectionRDS)
            response = rds_velocity_command_correction(request)
        except rospy.ServiceException as e:
            print("Service call failed: {}".format(e))

        forward = response.corrected_command.linear
        left = response.corrected_command.angular * virtual_center_y

        return forward, left

    def odom_callback(self, msg):
        self.odom = msg

    def tf_callback(self, event=None):
        try:
            self.tf_rob_in_fix = self.tf_listener.lookupTransform(
                self.kFixedFrame, self.kRobotFrame, rospy.Time(0)
            )
        except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
            return
        # periodically publish goal tf
        time = rospy.Time.now()
        if self.last_tf_publish_time and time == self.last_tf_publish_time:
            # this should not happen, as we told ROS we want to run the callback every 10ms,
            # but it still does. what the hell?
            return
        if self.tf_goal_in_fix is not None:
            self.tf_br.sendTransform(
                self.tf_goal_in_fix[0],
                self.tf_goal_in_fix[1],
                time,
                "goal",
                self.kFixedFrame,
            )
        self.last_tf_publish_time = time

    def global_waypoint_callback(self, msg):
        """ If a global path is received (in map frame), try to track it """
        with self.lock:
            waypoint_in_msg = np.array([
                msg.pose.position.x,
                msg.pose.position.y,
            ])
            # msg frame to fixed frame
            if self.kFixedFrame != msg.header.frame_id:
                time = msg.header.stamp
                try:
                    time = msg.header.stamp - rospy.Duration(0.1)
                except TypeError:
                    pass
                try:
                    tf_msg_in_fix = self.tf_listener.lookupTransform(
                        self.kFixedFrame,
                        msg.header.frame_id,
                        time,
                    )
                except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException) as e:
                    print("Could not find transform from waypoint frame to fixed.")
                    print(e)
                    return
                waypoint_in_fix = apply_tf(waypoint_in_msg, Pose2D(tf_msg_in_fix))
            else:
                waypoint_in_fix = waypoint_in_msg
            new_tf_goal_in_fix = (np.array([waypoint_in_fix[0], waypoint_in_fix[1], 0.]),  # trans
                                  tf.transformations.quaternion_from_euler(0, 0, 0))  # quat
            # detect changes
            is_changed = True
            if self.tf_goal_in_fix is not None:
                if (np.allclose(self.tf_goal_in_fix[0], new_tf_goal_in_fix[0]) and
                        np.allclose(self.tf_goal_in_fix[1], new_tf_goal_in_fix[1])):
                    is_changed = False
            self.tf_goal_in_fix = new_tf_goal_in_fix
            if is_changed:
                rospy.loginfo_throttle(5., "RDSPlanner: new waypoint received and set.")

    def controller_routine(self, event=None):
        atic = timer()
        if self.odom is None:
            print("odom not received yet")
            return
        if self.tf_rob_in_fix is None:
            print("tf_rob_in_fix not found yet")
            return
        if self.tf_goal_in_fix is None:
            self.tf_goal_in_fix = self.tf_rob_in_fix
            print("rdsplanner: waypoint set to robot position (scan callback)")
        if self.STOP and not PLAN_EVEN_IF_STOPPED:
            return

        # dwa
        # Get state
        # goal in robot frame
        goal_in_robot_frame = apply_tf_to_pose(
            Pose2D(self.tf_goal_in_fix), inverse_pose2d(Pose2D(self.tf_rob_in_fix)))
        gx = goal_in_robot_frame[0]
        gy = goal_in_robot_frame[1]

        # robot speed in robot frame
#         u = self.odom.twist.twist.linear.x
#         v = self.odom.twist.twist.linear.y
#         w = self.odom.twist.twist.angular.z

        best_u, best_v = self.rds_correction(gx, gy)

        # Slow turn towards goal
        # TODO
        best_w = 0
        WMAX = 0.5
        angle_to_goal = np.arctan2(gy, gx)  # [-pi, pi]
        if np.sqrt(gx * gx + gy * gy) > 0.5:  # turn only if goal is far away
            if np.abs(angle_to_goal) > (np.pi / 4 / 10):  # deadzone
                best_w = np.clip(angle_to_goal, -WMAX, WMAX)  # linear ramp

        # add safety margins
#         SIDEWAYS_FACTOR = 0.3 if self.args.forward_only else 1.
#         best_u_safe = np.clip(best_u * 0.5, -0.3, 0.3)
#         best_v_safe = np.clip(best_v * 0.5 * SIDEWAYS_FACTOR, -0.3, 0.3)
        best_u_safe = best_u
        best_v_safe = best_v

        # step-through if necessary
        if self.step_through_flag and self.args.forward_only:
            if best_u_safe < STEP_THROUGH_VEL:
                best_u_safe = STEP_THROUGH_VEL

        # publish cmd_vel
        if not self.STOP:
            # publish cmd_vel
            cmd_vel_msg = Twist()
            cmd_vel_msg.linear.x = best_u_safe
            cmd_vel_msg.linear.y = best_v_safe
            cmd_vel_msg.angular.z = best_w
            if not np.isnan(best_u_safe) and not np.isnan(best_v_safe):
                self.cmd_vel_pub.publish(cmd_vel_msg)

        # publish cmd_vel vis
        pub = rospy.Publisher("/dwa_cmd_vel", Marker, queue_size=1)
        mk = Marker()
        mk.header.frame_id = self.kRobotFrame
        mk.ns = "arrows"
        mk.id = 0
        mk.type = 0
        mk.action = 0
        mk.scale.x = 0.02
        mk.scale.y = 0.02
        mk.color.b = 1
        mk.color.a = 1
        mk.frame_locked = True
        pt = Point()
        pt.x = 0
        pt.y = 0
        pt.z = 0.03
        mk.points.append(pt)
        pt = Point()
        pt.x = 0 + best_u * self.kDT
        pt.y = 0 + best_v * self.kDT
        pt.z = 0.03
        mk.points.append(pt)
        pub.publish(mk)
        pub = rospy.Publisher("/dwa_goal", Marker, queue_size=1)
        mk = Marker()
        mk.header.frame_id = self.kRobotFrame
        mk.ns = "arrows"
        mk.id = 0
        mk.type = 0
        mk.action = 0
        mk.scale.x = 0.02
        mk.scale.y = 0.02
        mk.color.g = 1
        mk.color.a = 1
        mk.frame_locked = True
        pt = Point()
        pt.x = 0
        pt.y = 0
        pt.z = 0.03
        mk.points.append(pt)
        pt = Point()
        pt.x = 0 + gx
        pt.y = 0 + gy
        pt.z = 0.03
        mk.points.append(pt)
        pub.publish(mk)
        pub = rospy.Publisher("/dwa_radius", Marker, queue_size=1)
        mk = Marker()
        mk.header.frame_id = self.kRobotFrame
        mk.ns = "radius"
        mk.id = 0
        mk.type = 3
        mk.action = 0
        mk.pose.position.z = -0.1
        mk.scale.x = self.kRobotComfortRadius_m * 2
        mk.scale.y = self.kRobotComfortRadius_m * 2
        mk.scale.z = 0.01
        mk.color.b = 1
        mk.color.g = 1
        mk.color.r = 1
        mk.color.a = 1
        mk.frame_locked = True
        pub.publish(mk)

        atoc = timer()
        if self.args.hz:
            print("DWA callback: {:.2f} Hz".format(1 / (atoc - atic)))

    def trackedpersons_callback(self, msg):
        try:
            tf_msg_in_rob = self.tf_listener.lookupTransform(
                self.kRobotFrame, msg.header.frame_id, msg.header.stamp)
        except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
            return
        p2_msg_in_rob = Pose2D(tf_msg_in_rob)
        for track in msg.tracks:
            pose = [track.pose.pose.position.x, track.pose.pose.position.y]
            pose_in_rob = apply_tf(np.array([pose]), p2_msg_in_rob)[0]
            vel = [track.twist.twist.linear.x, track.twist.twist.linear.y, 0]
            vel_in_rob = apply_tf_to_vel(np.array(vel), p2_msg_in_rob)
            is_in_front = pose_in_rob[0] > 0
            is_close = np.linalg.norm(pose_in_rob[:2]) <= 2.
            is_static = np.linalg.norm(vel_in_rob[:2]) <= 0.5
            if is_in_front and is_close and is_static:
                if not self.STOP and self.GESTURES:
                    self.step_through_flag = True
                    self.speech_pub.publish(String("I'm passing through, thank you!"))
                    self.gestures_pub.publish(String("animations/Stand/Gestures/You_2"))
                    rospy.sleep(self.kGesturesCooldownTime)
                    self.gestures_pub.publish(String("animations/Stand/Gestures/Desperate_4"))
                    rospy.sleep(self.kGesturesCooldownTime)
                    self.step_through_flag = False
                    return

    def enable_gestures_service_call(self, req):
        with self.lock:
            if not self.GESTURES:
                rospy.loginfo("Enabling gestures.")
            self.GESTURES = True
        return TriggerResponse(True, "")

    def disable_gestures_service_call(self, req):
        with self.lock:
            if self.GESTURES:
                rospy.loginfo("Disabling gestures.")
            self.GESTURES = False
        return TriggerResponse(True, "")

    def stop_autonomous_motion_service_call(self, req):
        with self.lock:
            if not self.STOP:
                print("Surrendering robot control")
                cmd_vel_msg = Twist()
                self.cmd_vel_pub.publish(cmd_vel_msg)
            self.STOP = True
        return TriggerResponse(True, "")

    def resume_autonomous_motion_service_call(self, req):
        with self.lock:
            if self.STOP:
                print("Assuming robot control")
                # re set goal
                if self.tf_rob_in_fix is None:
                    print("couldn't reset goal: tf_rob_in_fix not found yet")
                else:
                    self.tf_goal_in_fix = self.tf_rob_in_fix
                    print("rdsplanner: waypoint set to current position (assumed control)")
            self.STOP = False
        return TriggerResponse(True, "")


def parse_args():
    import argparse
    # Arguments
    parser = argparse.ArgumentParser(description='RDSPlanner motion planner for pepper')
    parser.add_argument(
        '--no-stop',
        action='store_true',
        help='if set, the planner will immediately send cmd_vel instead of waiting for hand-over',
    )
    parser.add_argument(
        '--hz',
        action='store_true',
        help='if set, prints planner frequency to script output',
    )
    parser.add_argument(
        '--forward-only',
        action='store_true',
        help='if set, the planner is only allowed to move forwards',
    )
    parser.add_argument(
        '--gestures',
        action='store_true',
        help='if set, gestures are enabled from the start',
    )

    ARGS, unknown_args = parser.parse_known_args()

    # deal with unknown arguments
    # ROS appends some weird args, ignore those, but not the rest
    if unknown_args:
        non_ros_unknown_args = rospy.myargv(unknown_args)
        if non_ros_unknown_args:
            print("unknown arguments:")
            print(non_ros_unknown_args)
            parser.parse_args(args=["--help"])
            raise ValueError
    return ARGS


if __name__ == "__main__":
    args = parse_args()
    planner = RDSPlanner(args)
